"""
	Алгоритм Дейкстры (Определение кратчайшего пути для взвешенных графов)

		+ Все ребра должны иметь НЕОТРИЦАТЕЛЬНЫЙ вес, иначе нужно исп алгоритм Беллмана-Форда
		+ Графы должны быть НеНАПРАВЛЕННЫМИ и АЦИКЛИЧНЫМИ
		
		Алгоритм:
			1) Находим самого близкого по расстоянию соседа
			2) Расчитываем расстояние до соседей, обновляем таблицы при неоходимости 
				(если до соседних узлов расстояние от начала уменьшилось, то обновляем таблицы)
			3) Повторяем это для всех узлов
	
"""

# Найти узел с нименьшей стоимостью
def find_lowest_cost_node(costs):
	lowest_cost = float("inf")
	lowest_cost_node = None
	for node in costs:              # Перебрать все узлы
			cost = costs[node]
			if cost < lowest_cost and node not in proccessed: # Если узел имеет меньшую стоимость и еще не обработан
					lowest_cost = cost                            # Назначить его новым узлом с наименьшей стоимостью
					lowest_cost_node = node
	return lowest_cost_node

"""
Исходный граф:
			/ A \
start		|	 fin
			\	B /

		 6/ A \1
start	 3|	 fin
		 2\	B /5

Хэш-таблица графа (graph):
	_________________
 |Начало | A |  6  |
 |			 | B |  2  |
 |-------|---|-----|
 |  A 	 |fin|  1  |
 |			 |   |     |
 |-------|---|-----|
 |  B 	 | A |  3  |
 |			 |fin|  5  |
 |-------|---------|
 | Конец |		-	   |
 |_______|_________|

Стоимости (costs):
	_________
 | A |  6  |
 |---|-----| 
 | B |  2  |
 |---|-----|
 |fin| inf |
 |___|_____|

Родители (parents):
	_________
 | A |start|
 |---|-----| 
 | B |start|
 |---|-----|
 |fin|  -  |
 |___|_____|

"""
graph["start"] = {}

graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {}

	node = find_lowest_cost_node(costs) # Узел с наименьшей стоимостью среди необработанных
	while node is not None: # Выполнять пока не просмотрим все узлы
			cost = costs[node]
			neighbors = graph[node]
			for n in neighbors.keys(): # Перебрать всех соседей текущего узла
					new_cost = cost + neighbors[n] 
					if costs[n] > new_cost: # Если к соседу можно добраться быстрее через текущий узел
							costs[n] = new_cost # То обновляем стоимость для этого узла
							parents[n] = node   # То этот узел становится новым родителем для соседа
			proccessed.append(node)     # Узел помчается как обработанный
			node = find_lowest_cost_node(costs) # Следующий узел с наименьшей стоимостью среди необработанных