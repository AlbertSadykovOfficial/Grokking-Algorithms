"""

		Динамическое программирование - разибение задач на подзадачи
		
		Работает в том случае, если каждая подзадача автономна (не должна зависеть от других)

		При решении задач динамическим методом:
			1) Строится таблица
			2) Значения ячеек соответствуют оптимизированной характеристике
			3) Каждая ячейка - подзадача (поэтому надо думать как разбить задачу на подзадачи) 
		
		Не существует формулы для решения задач методом динамического программирования, на то оно и динамическое
"""
"""
					Алгоритмом Феймана:
						1) Записать формулировку задач
						2) Хорошенько подумаь
						3) Записать решение
"""

"""
		Рассмотрим применение динамического программирования
		на примере поисковой системы.
		
		Задачи:
			1) Самая длинная общая подстрока
			2) Самая длинная общая подпослеовательность

"""

"""
		ЗАДАЧА 1 - Самая длинная общая подстрока
				
		Человека ввел: hish
		Вопрос: что он вероятнее имел ввиду: fish или vista?

				Построение таблицы 
					Вопросы:
						1) Какие значения должны содержаться в ячейках?
						2) Как разбить задачу на подзадачи?
						3) Каков смысл осей таблицы?

				Будем считать, что мы ищем самую длинную подстроку, общую для 2х слов
					
					Предположим, что надо сравнить подстроки, отсюда получаем матрицу
					Каждая ячейка будет содержать длину самой длинной подстроки, обзей для 2х подстрок:

						h i s h
					f
					i
					s
					h

					Решение:
					(Чтобы понять, нужно подвигать слова: fish-> ishn, fish-> hhsh)
						h i s h
					f 0 0 0 0
					i 0 1 0 0
					s 0 0 2 0
					h 0 0 0 3
					

"""

# Решение:
word_a = ['h', 'i', 's', 'h']
word_b = ['f', 'i', 's', 'h']
cell = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]

prev_i = 0
prev_j = 0

for i in range(0,len(word_a)):
	for j in range(0,len(word_b)):
		if word_a[i] == word_b[j]:
			cell[i][j] = cell[prev_i][prev_j] + 1
		else:
			cell[i][j] = 0
		prev_j = j
	prev_i = i

for x in cell:
		print(x)

print("\n\n")

"""
	
	ЗАДАЧА 2 - Самая длинная общая подпослеовательность
	
	Человека ввел: fosh
	Вопрос: что он вероятнее имел ввиду: fish или fort?


		Если решать задачу через Самую длинную общую подстроку (как в предыдущем примере)
		То окажестя, что fort подходит больше, чем fish,
		Но у fosh и fish совпаают 3 буквы из 4 - это слово более подходящeе

		Эта ошибка возникла из-за того, что в предыдущем алгоритме акцент на ПОСТРОКУ,
		А нужно сравнивать ПОДПОСЛЕДОВАТЕЛЬНОСТЬ (кол-во букв в последовательности общих для 2х слов)

"""

# Решение:
word_a = ['f', 'i', 's', 'h']
word_b = ['f', 'o', 's', 'h']
word_c = ['f', 'o', 'r', 't']
cell = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]

# Нужно, чтобы не выйти за пределы массива [i-1][j-1] 
prev_i = 0
prev_j = 0

for i in range(0,len(word_a)):
	for j in range(0,len(word_b)):
		if word_a[i] == word_b[j]:
			cell[i][j] = cell[prev_i][prev_j] + 1
		else:
			cell[i][j] = max(cell[prev_i][j], cell[i][prev_j])
		prev_j = j
	prev_i = i

for x in cell:
		print(x)
