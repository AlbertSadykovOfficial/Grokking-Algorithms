"""
	Графы - Поиск в ширину
					(breadth_first_search)
	Граф - система объектов состоящих из узлов* и ребер*
			Узел может быть соединен с другими узлами - соседями.
			Реализуется на хэш-таблицах.

			Типы:
				 Направленные - отношение только в 1 сторону (Я сын Мамы, но Мама не мой сын)
				 Ненаправленные - отношение в обе стороны (Я друг Гранта, Грант мой друг)

	АЛГОРИТМ Поиска в ширину:
	Скорость O(V+E), 
					где 
						V - кол-во вершин (людей)
						E - кол-во ребер (связей)

	Поиск в ширину Отвечает на вопросы:
			1) Существует ли путь от узла А к узлу Б
			2) Как выглядит "кратчайший путь" от зула А к узлу Б
		
		Кратчайшим расстоянием может быть:
			- Шашки - кратчайшй путь к победе
			- Проверка правописаия (минимальное кол-во изменений, преобразующих ошибочно написанное слово в правильное)
			- Найти ближайшее место

		Принцип:
				Задача: Нам надо найти Барыгу Манго
				Мыслим следующим образом:
					1) Поискать среди своих Друзей
					2) Если не найдем, то искать у друзей Друзей
							Но при этом сначала ИМЕННО проверить своих Друзей, а потом углубляться
							в друзей Друзей, чтобы еще и найти кратчайший путь
							Это реализуется за счет ОЧЕРЕДЕЙ (FIFO)
		
		Реализация:
			Из принципа можно понять, что граф имеет отношение типа: Я->[Друг№1, Друг№2, Друг№3...] 
			Отсюда, если нам нужен доступ по значению(Имени) с выосокой скоростью, то надо использовать Хэш-таблицы

			P.S. Т.к у человека несколько друзей, то результатом будет не 1 значение, а массив
"""

# Создать Граф
	graph = {}
	graph['Me'] = ['Grant','Anar','Nikita','Introvert']
	graph['Nikita'] = ['Kim', 'PersonX']
	graph['Introvert'] = []

# Функция для примера
# Если последняя буква имени m, считаем, что человек - Барыга
def person_is_seller(person):
	return name[-1] == 'm'


# Алгоритм Поиска в ширину

from collections import deque
	search_queue = deque() # Соззать очередь
	search_queue += graph['Me']

	while search_queue:
		person = search_queue.popleft() # Достать первого из очереди
		if person_is_seller(person):
			print person + 'is a Mango seller'
			return True
		else:
			search_queue += graph[person] # Все друзья человека добавляются в очередь, если он не Барыга


# Алгоритм Поиска в ширину с защитой от зацикивания
# Если у друга Друга есть Мы в друзьях, то мы добавим себя в очередь, а потом все пойдет по кругу

def search(name):
	search_queue = deque() # Соззать очередь
	search_queue += graph[name]
	searched = [] # Отслеживание уже проверенных людей (защита от ацикливания)
	while search_queue:
		person = search_queue.popleft()
		if not person in searched:
			if person_is_seller(person):
				print person + 'is a Mango Seller'
				return True
			else:
				search_queue += graph[person] # Все друзья человека добавляются в очередь, если он не Барыга
				searched.append(person) # Поместить человека в списки проверенных
	return False

search("Me")