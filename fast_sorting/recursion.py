"""
		Стратегия "Разделяй и властвуй"

		Решение задачи при таком методе состоит из 2х шагов:
			1) Определить Базовый случай. (простейший из всех возможных)
			1.1) Надо придумать как свести задачу к базовому случаю.
			2) Задача делится и сокращается до тех пор, пока не будет сведена к базовому случаю

			Дано:
			 ___1680___
			|          | 640
			|__________|

			Найти: 
				Разделить на минимальные одинаковые квадратные участки

			Решение:
				Определим Базовый случай:
				Самое простая ситуация - длина одной стороны кратна дллине другой:

							 ___50___
							|        | 25
							|________|
				
				Исходный:
						 ____________      __
						| x  | x  |!x|==> |!x| ==>  (Делим дальше, пока не получим БАЗОВЫЙ СЛУЧАЙ)
						|____|____|__|    |__|    <-(По этой картинке он уже найден, но это так получилось)

						После того, как мы найдем базовый случай, то мы получим соотношение:
						160x80, что дает 2 квадрата со сторонами 80x80

		В данной стратегии обычно:
			Базовым случаем является пустой массив или массив из 1 элемента

"""

# Рекурсивное суммирования
# Базовый случай - массив с 0 или 1 элементом
# При каждом рекурсивном вызове мы должны приближаться к ПУСТОМУ МАССИВУ (уменьшение задачи)
def sum(arr):
	if arr == []:
		return 0
	return arr.pop() + sum_req_ex_1(arr)
		

def count(arr):
	if len(arr) != 0:
		arr.pop()
		return 1 + count_req_ex_1(arr)
	else:
		return 0

def maxx(arr,max_val):
	if len(arr) != 0:
		if arr[0] > max_val:
			max_val = arr.pop(0)
		else:
			arr.pop(0)
		return max_req_ex_1(arr,max_val)
	else:
		return max_val

num = [1,2,3,4,5]
#print('Рекурсивное суммирование: ', sum(num))
#print('Рекурсивное подсчет элементов: ', count(num))
print('Максимальное значение: ', maxx(num, num[0]))