"""

	Детали реализации

		СВОЙСТВА дерево поиска:
			В бинарном дереве ПОИСКА каждый кзел соответсвует объекту (с ключом)
			и имеет ТРИ ассоциируемых УКАЗАТЕЛЯ: на РОДИТЕЛЯ, на ПРАВОГО и на ЛЕВОГО потомков.
			Любой из 3х указателей может быть пустым и содержать null.

			Непосредственно свойства:
				1) Для каждого объекта x объекты в ЛЕВОМ поддереве
						имеют ключи меньше, чем у x
				2) Для каждого объекта x объекты в ПРАВОМ поддереве
						имеют ключи больше, чем у x

						x
			a<x  / \  x<b
					a   b

				Пример:
										3
									/		\
								1			  5
								 \		 /
									2	  4	 
			
			ОТЛИЧИЕ Бинарного дерева от КУЧИ:
				1) Куча можно рассматривать как деревья, 
					но они реализованы как массивы, без явных укзаателей между объектами.
					ДЕРЕВО поиска хранит 3 указателя.

				2)	Кучам явные указатели не нужны, потому что они соответсвуют полным
					бинарным деревьям
					ДЕРЕВО поиска может иметь произвольную структуру.

				3) Кучи и деревья поиска имеют разное предназначение
					 Кучи - для вычислений минимума
					 Деревья поиска - для поиска.

			ВЫСОТА (глубина) дерева поиска

				ВЫСОТА дерева поиска - длина самого длинного пути от корня до листа.

				В общем случае: от log2(n) до n-1


			РЕАЛИЗАЦИИ ОПЕРАЦИЙ:

				ОТЫСКАТЬ:
					1) НАЧАТЬ С КОРНЕВОГО УЗЛА
					2) Идти налево (если x < ключа текущего узла)
						 или направо (если x > ключа текущего узла)
					3) Вернуть указатель на объект с ключом (x), если он найден
						 Вернуть null, если объект не найден

				МИНИМУМ И МАКСИМУМ:
					1) НАЧАТЬ С КОРНЕВОГО УЗЛА
					2) Если надо  минимум, то идти по левому пути до null
						 Если надо максимум, то идти по првому пути до null
					3) Вернуть указатель на последний посещенный объект.

																10
														 //		\\
						(тут минимумы)	1			  50  (тут максимумы)
												 //	 \		 /  \\
								 min	-> 0		2	  20	 100 <- max

				ПРЕДШЕСТВЕННИК:
					1) Если левое дерево не пустое, то вернуть результат
						 операции МАКСИМУМ (т.к большее из меньших и будет предшественником)
					2) В проивном случае (...............)
					3) В противном случае - не найден (null) 
				
				ВЫВЕСТИ В ОТСОРТИРОВАНОМ ПОРЯДКЕ:
					1) Рекурсивно вызвать операцию ВЫВЕСТИ В ОТСОРТИРОВАНОМ ПОРЯДКЕ на ЛЕВОМ поддереве
					2) Вывести объект в корне
					3) Рекурсивно вызвать операцию ВЫВЕСТИ В ОТСОРТИРОВАНОМ ПОРЯДКЕ на ПРАВОМ поддереве

				ВСТАВИТЬ:
					1) НАЧАТЬ С КОРНЕВОГО УЗЛА
					2) Идти налево (если x < ключа текущего узла)
						 или направо (если x > ключа текущего узла)
						 ДО ТЕХ ПОР пока не наткнемся на null укзаатель
					3) Заменить пустой укзаатель на новый объект.
						 Установить у нового узла указатель на родителя + 2 null указаеля на потомков.

				УДАЛИТЬ:
					1) ОТЫСКАТЬ объект x с ключом k (если нет, то завершить выполнение)
					2) ЕСЛИ x не имеет потомков, 
						 ТО удалить x путем установки указателя на потомка в родителе узла x = null
			 					Пример:
										3          						3
									/		\									/		\
								 1		 5			-->			 1		 5
								 \		/										  /
			Удалить	->	2	 4	 									 4

					3) ЕСЛИ x имеет одого потомка,
						 ТО отсоединить x, заменив укзатель потомком в родителе узла x с потомком узла x
						 (Если x был корнем, то его потомок становится новым корнем).
			 				
			 				Пример:
										3											3
									/		\									/		\
								1			  5 <- Удалить	 1		 4
								 \		 /								\
									2	  4	 								 2

					4) В противном случае заменить x объектом в его левом поддереве, который имеет самый
						 юольшой клююч, и удалить x из его новой позиции (где онимеет не более 1 потомка)
			 					Пример:
				Удалить	->	3											2		 					2
									/		\									/		\					/		\
								1			  5		 -->			 1		  5	-->	 1		 5
								 \		 /								\		 /						/
		 Предшеств.-> 2	  4		  Нарушение -> 3	4						 4	 

				ВЫБРАТЬ:
					Чтобы реализовать операцию выбрать за короткое время, нужно отслеживать информацию
					о структуре самого дерева, а не только об объектке.
					Усиливать деервья можно разными способами, в этом случае будем хрантить в каждом
					узле x размер size(x), который говорит сколько улов в поддереве с корнем x (вкл. x).

					Пример:

										3 size(3)=5
									/		\
		size(1)=2		1			  5 size(5)=2
								 \		 /
				size(2)=1	2	  4	 size(4)=1

					Как применить эти размеры?
						Дано: Нужно найти объект с 17м наименьшм ключом (i=17) в дереве из 100 объектов.
						Начиная с корня за const время мы можем вычислить размеы левого и правого поддерев.

						Если популяция левого поддерева = 25, то это 25 наименьших ключей в дереве, вкл 17й наим.
						Если популяция левого поддерева = 12, то 17й ключ в правом деерве и он явл 4м наименьшм там.

						Итог: Чтобы найти расположение объекта, мы можем вызвать функцию ВЫБРАТЬ рекурсивно.

						1) Начать с корня, j=размеру левого поддерева (если его нет, то 0)
						2) Если i = j+1, то вернуть указатель на корень
						3) Если i < j+1, то рекурсивно вычислить i-й наименьший ключ в ЛЕВОМ поддереве
						4) Если i > j+1, то рекурсивно вычислить (i-j-1)-й наименьший ключ в ПРАВОМ поддереве
	 				 


"""