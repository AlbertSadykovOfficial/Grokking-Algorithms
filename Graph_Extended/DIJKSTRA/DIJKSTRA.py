"""
	
		Алгоритм кратчайшего пути Дейкстры (протсая реализация)

			Алгоритм Дейкстры работает в ориентированном графе с НЕОТРИЦАТЕЛЬНЫМИ ребрами
			и вычисляет длины кратчайших путей из стартовой до всех остальных вершин.
			Задачу он решает только с ЕДИНСТВЕННЫМ ИСТОКОМ.

			Время выполнения: 0(mn)

			Так же алгоритм применим и для неориентированных графов при некотором изменении кода.
			
			Вопрос:
				Почему бы нам не вычислять длину пути как и раньше через BFS?
			Ответ:
				Потому что BFS вычисляет кол-во ребер, что явл. частным случаем алгоритма Дейкстры
				с длиной ребра равным 1. При этом самый короткий путь не обязательно состоит из
				меньшего числа ребер, все зависит от веса ребра. Вес у ребра, к примеру, часто встречается 
				в дорожном графе как длина дороги.
				При этом, конечно, если ребро имеет отличную от 1 длину (скажем 3), 
				его можно разбить на несколько ребер (3 в нашем случае), что создаст граф с единичными ребрами.
				Такой механизм называется РЕДУКЦИЕЙ-> приведение одной задачи к другой.
				Это сработает на малых масштабах, но если ребра будут иметь большие длины, 
				ТО узлы графа разрастутся, а время выполнения алгоритма BFS O(n)... Время сильно увеличится.  
	
			ПСЕВДОКОД:

				X:= {s}
				len(s):= 0, len(v):= ∞ для каждого v != s

				while существует ребро (v,w), где v->X, w!->X do
						(v*, w*):= такое ребро, которое миимизирут len(v) + l_vw
						добавить w* в X
						len(w*):= len(v*) + l_v*w*

				Т.е алгоритм всегда обрабатывает вершину, которая располагается наиболее ближе 
				к стартовой вершине (за исключением уже проверенных)  

				Пример:
						1	  6
					 -> v ->
				  / 	 		\
				 s    |2   t
				  \ 	v		/
					 -> w -> 	
						4   3

					1) Изначально множество X содержит только s и len(s)=0
					ПЕРВАЯ ИТЕРАЦИЯ 
						1) Есть 2 ребра на выбор : (s,v) и (s,w)
						2) Высчитываем оценки:
								3.1 len(s) + len_sv = 0+1 = 1  - (Меньшая оценка - ВЫБИРАЕМ ЕЕ)
								3.2 len(s) + len_sw = 0+4 = 4
								После выбора оценке len(v) назначается (1)
					ВТОРАЯ ИТЕРАЦИЯ
						1) Есть 3 ребра на выбор: (s,w) (v,w), (v,t)
						2) Высчитываем оценки:
								3.1 len(s) + len_sw = 0+4 = 4
								3.2 len(v) + len_vw = 1+2 = 3  - (Меньшая оценка - ВЫБИРАЕМ ЕЕ)
								3.3 len(v) + len_vt = 1+6 = 7
								После выбора оценке len(w) назначается (3)
					ТРЕТЬЯ ИТЕРАЦИЯ:
						1) Есть 2 ребра на выбор: (v,t) и (w,t)
						2) Высчитываем оценки:
								3.1 len(v) + len_vt = 1+6 = 7
								3.2 len(w) + len_wt = 3+3 = 6  - (Меньшая оценка - ВЫБИРАЕМ ЕЕ)
					
					Полученные оценки соответсвуют истиным кратчайшим расстояниям:
						len(s) = 0
						len(v) = 1
						len(w) = 3
						len(t) = 6


				Почему алгоритм не работает с отрицательными ребрами (пример):
					
					Может возникнуть идея, что если есть отрицательные ребра, 
					то можно добавить к весу всех ребер какое-то число, чтобы все ребра
					стали положительными, но это не так, стоит взглянуть на следующие
					примеры и вычислить кратчайшие пути в 1м и 2 случае:

					1й случай (Исходный)
						 1	 -5
						 > v >
						/     \
					 s  -->  t
					 		-2

					 Итог: кратчайший путь (s->v->t)

					2й случай (Добавим 5 ко всем ребрам)
 						 6	 0
						 > v >
						/     \
					 s  -->  t
					 		 3
					Итог: кратчайший путь (s->t)

"""