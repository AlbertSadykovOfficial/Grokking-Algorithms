"""

		Вычисление сильно связных компонент - алгоритм Косарайю.

			Замечание:
				Графовый поиск МОЖЕТ выявлять сильно связные компоненты
				ПРИ УСЛОВИИ, что мы НАЧИНАЕМ С ПРАВИЛЬНОГО МЕСТА.

			Принцип работы:
				1) Первый проход в глубину вычислет упорядочение
				2) Второй подчиняется упорядочению с целью обнаружить SCC одну за другой.

			Алгоритм (Выскоуровневый)
				1) Разворачиваем граф G в обратную сторону (G.rev)
				2) Вызвать DFS из каждой вершины графа G.rev, обработ. в произвольном порядку,
					 чтобы вычислить позицию f(v) для каждой вершины v
				3) Вызвать DFS из каждой вершины G, обработанной от самой высокой до самой низкой
				   позиции, для того, чтобы выичлить идентичность сильно связного компонента каждой вершины.
				
				Зачем нам обратный граф?
					Ответ: Знать СТОК важно для второго прохода поиска в Глубину. (А ПОЧЕМУ? - Пока не дошло до меня)

					Как получить СТОК через обратный граф: 
					Дело в том, что если применить алгоритм TopoSort в Метаграфе, то если мы выбирем неправильную
					вершину, то не найдем SSC СТОК (так как есть зацикливание), при этом мы всегда найдем SCC ИСТОК,
					так как значения f(v) дается каждому узлу, а алгоритм TopoSort заканчивает свою работу на ИСТОКе,
					(исходя и свойства свойство ацикличности)
					то даже несмотря на зациклиность, один из узлов в истоковом SCC получит f(v) = 1.
					Т.е. первая вершина находится в ИСТОКОВОЙ SCC.
					ПОЭТОМУ, если мы развернем граф и применим алгоритм TopoSort, то мы сможем найти СТОК SCC.
					

			Топологическое упорядочивание сильно связных компонент:
				Пусть G - ориент. граф, вершины котррого упорядочены произвольно,
				пусть для каждой вершины v->V f(v) обозачает позицию v, вычисляемую через TopoSort.
				Пусть S1 и S2 обозначают две SCC графа G.
				Пусть G имеет ребро (v,w), где v->S1 и w->S2
				Тогда:
														min f(x) < min f(y), где x->S1, y->S2
				
				Следствие из теоремы для обратного графа:
													min f(x) > min f(y), где x->S1, y->S2
					В частости: Вершина в первой позиции располагается в SCC графа G.
					Такая вершина является идеальной стартовой точкой для 2го прохода поиска в глубину.

			
			ПСЕВДОКОД для алгоритма КОСАРАЙЮ:

				Вход: ориентированный граф G=(V,E), представленный в виде списков смежности, с V={1,2,3, ... ,n}
				Постусловие: scc(v) = scc(w) тогда, когда v и w принадлежат одной SCC.

				1) G.rev = G, в котором все ребра развернуты в обратную сторону
				2) пометить все вершины G.rev как неразведанные
					 // Первый проход поиска в глубину
					 // Вычисляет позиции f(v)
				3) TopoSort(G.rev)
					 // второй проход поиска в глубину
					 // (находит SCC в обратном порядке)
				4) пометить все вершины G как неразведанные
				5) numSCC:= 0 // Global Var
				6) for каждая v->V, в порядке возрастания f(v) do
				7)   if v не разведана then
				8)     numSCC:= numSCC + 1
							 // назначить SCC-значения
				9)     DFS-SCC(G,v)

				Замечание 1 :
					Мы сделали копию графа и развернули ее.
					НО МОЖНО поменять функцию DFS-Topo ПУТЕМ ЗАМЕНЫ:
					"каждое ребро (s,v) в исх. списке смежности"
					НА -> "каждое ребро (v,s) в исх. списке смежности"
				
				Замечание 2 :
					Для лучшей производительности первый проход поиска в глубину должен:
					экспортировать массив, содержащий вершины в порядке их позиций.
					Цель: Чтобы второй проход смог обрабатывать их с помощью сканирования массива. 
				Замечание 3 :
					Подпрограмма DFS-SCC отличается от DFS:

					function ():
						scc(s):= numSCC  // Global Var, ПРВЕДЕННАЯ ВЫШЕ
						for каждое ребро (s,v) в списке смежности вершины s do
								if v не разведана then
										DFS-SCC(G,v)
"""