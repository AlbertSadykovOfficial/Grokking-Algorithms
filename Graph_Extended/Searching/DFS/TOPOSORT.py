"""

	Топологическая сортировка

		DFS подходит для выичсления топологического упорядочивания
		Ориентированного ациклического графа (directed acyclic graph - DAG)

			Ориентированный - имеет направление
			Ациклический - не зацикливается
	
		Топологическое упорядочивание

			Пусть G=(V,E) - ориентированный граф.
			Т.У. графа G является закрепление за f(v) в каждой вершине v->V 
			отличающегося числа, такого, что для каждого (v,w)->E:
											 f(v)<f(w)
			
			Функция f упорядочивает вершины от верш. с наим f до верш с наиб. f.
			Это говорит о том, что метка ХВОСТА ребра должна быть МЕНЬШЕ метки ГОЛОВЫ.
			
			Топологическое упорядочивание может иметь только тот граф, который не имеет 
			ориентированных циклов.


			Топологическое упорядочивание применимо для построения последовательности
			операций с целью соблюдения всех ограничений по предшестованию.

			Ограничением по предшетсвованию - мы не можем начать некоторые задчи
			о тех пор, пока не завершатся другие. 

			Пример:
				 -> v ->
				/ 	 		\
			s          t
				\ 			/
				 -> w ->

				Для данного графа существует 2 топологических упорядочения:
					1) s -> v -> t
					2) s -> w -> t 
				
				Примечание:
					s - истоковая вершина
					t - стоковая вершиная
				
				Следствие ацикличности:
					Отсюда: если мы будем двигаться по входящим ребрам назад из произвольной вершины DAG-графа,
					то мы достигнам истоковой вершины.
					Т.е каждый DAG-граф имеет топологическое упорядочивание


			ПСЕВДОКОД топологической сортировки (Процедурный метод):
				Вход: ориентированный ациклический граф G = (V,E) в виде Списков смежности
				Постусловие: значение f вершин образуют тополог. упорядочен. графа G.
				
				1) пометитить все вершины как неразведанные
				2) curLabel:= |V| // отслеживает упорядочение
				3) for каждая v->v do
				4) 	 if v не разведана then // в предыдущем DFS
				5)     DFS-Topo (G,v)

				При этом DFS-Topo немного отличается от процедурного DFS:
				ПСЕВДОКОД:
					Вход: ориентированный ациклический граф G = (V,E) в виде Списков смежности
					Постусловие: Каждая вершина, достижимая из s, помечается как разведанная и = f.

					1) поместить s как разведанную
					1) for каждое ребро (s,v) в исходящем списке смежности s do
					2)			if v не разведана then
					3)				DFS-Topo (G,v)
					4) f(s):=curLabel					 // позиция s в упорядочеии
					5) curLabel:= curLabel - 1 // двигаться справа налево

				Пример:
					 -> v ->
					/ 	 		\
				 s         t
					\ 			/
					 -> w ->

					 1) Алгорит TopoSort инициализирует глобальную переменную curlLabel как 4 (вершины)
					 2) Внешний цикл TopoSort перебирает верш. в произв. порядке, пусть: v,t,s,w
					 ПЕРВАЯ ИТЕРАЦИЯ:
					 	Поскольку v не помесчена как разведанная, вызывается DFS-Topo со старт. верш v
					 	Единственным исходящим ребром из v является (v,t)
					 	-> ПРОВАЛИВАЕМСЯ В РЕКУРСИЮ: 
							 	Рекурсивный вызов DFS-topo со стартовой вершиной t
							 	Вызов возвращается (т.к вершина t не имеет исходящих ребер) и f(t) уст. 4
							 	Переменная curlLabel уменьается с 4 до 3.
							 	[Вызов в подпрограмме v завершается]
						Так как v не имеет других исходящи ребер,то Переменная curlLabel уменьается с 3 до 2.
					ВТОРАЯ ИТЕРАЦИЯ:
						Вызывается DFS-Topo со старт. верш t
						t уже помечена как разведанная, пропускаем ее.
					ТРЕТЬЯ ИТЕРАЦИЯ:
						Вызывается DFS-Topo со старт. верш s
						->ПРОВАЛИВАЕМСЯ В РЕКУРСИЮ -> DFS-Top пропускает вершину v
						->ПРОВАЛИВАЕМСЯ В РЕКУРСИЮ:
								Рекурсивный вызов DFS-topo со стартовой вершиной w
								Вызов завершается (т.к единственное ребро ведет в изведанную t) 
								f(w) уст. как 2.
								curLabel уменьшается с 2 до 1
								[Вызов в подпрограмме w завершается]
						f(w) уст. как 1.
						[Вызов в s завершается]

"""